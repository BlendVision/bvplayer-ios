// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BVPSE
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Foundation
import Metal
import MetalKit
import MetalPerformanceShaders
import OpenGLES
import QuartzCore
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_inheritsConvenienceInitializers public class CannyEdgeDetection : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var upperThreshold: Swift.Float {
    get
    set
  }
  public var lowerThreshold: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class LinearBurnBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class MissEtikateFilter : BVPSE.LookupFilter {
  override public init()
  @objc deinit
}
public enum ImageOrientation {
  case portrait
  case portraitUpsideDown
  case landscapeLeft
  case landscapeRight
  public static func == (a: BVPSE.ImageOrientation, b: BVPSE.ImageOrientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Rotation {
  case noRotation
  case rotateCounterclockwise
  case rotateClockwise
  case rotate180
  case flipHorizontally
  case flipVertically
  case rotateClockwiseAndFlipVertically
  case rotateClockwiseAndFlipHorizontally
  public static func == (a: BVPSE.Rotation, b: BVPSE.Rotation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class HarrisCornerDetector : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var sensitivity: Swift.Float {
    get
    set
  }
  public var threshold: Swift.Float {
    get
    set
  }
  public var cornersDetectedCallback: (([BVPSE.Position]) -> ())?
  public init(fragmentShader: Swift.String = HarrisCornerDetectorFragmentShader)
  @objc deinit
}
public class BoxBlur : BVPSE.TwoStageOperation {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class RenderViewMTL : MetalKit.MTKView, BVPSE.ImageConsumer {
  @_Concurrency.MainActor(unsafe) public var newTextureAvailableCallback: (([Swift.UInt8], Swift.Int, Swift.Int) -> ())?
  @_Concurrency.MainActor(unsafe) final public let sources: BVPSE.SourceContainer
  @_Concurrency.MainActor(unsafe) final public let maximumInputs: Swift.UInt
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame frameRect: CoreFoundation.CGRect, device: (any Metal.MTLDevice)?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  @_Concurrency.MainActor(unsafe) public func newTextureAvailable(_ texture: BVPSE.Texture, fromSourceIndex: Swift.UInt)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
}
@_inheritsConvenienceInitializers open class TwoStageOperation : BVPSE.BasicOperation {
  public var overrideDownsamplingOptimization: Swift.Bool
  override public init(shader: BVPSE.ShaderProgram, numberOfInputs: Swift.UInt = super)
  override public init(vertexShader: Swift.String? = nil, fragmentShader: Swift.String, numberOfInputs: Swift.UInt = super, operationName: Swift.String = #file)
  override public init(vertexShaderFile: Foundation.URL? = nil, fragmentShaderFile: Foundation.URL, numberOfInputs: Swift.UInt = super, operationName: Swift.String = #file) throws
  @objc deinit
}
public class DarkenBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class SingleComponentGaussianBlur : BVPSE.TwoStageOperation {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FramebufferCache {
  public func requestFramebufferWithProperties(orientation: BVPSE.ImageOrientation, size: BVPSE.GLSize, textureOnly: Swift.Bool = false, minFilter: Swift.Int32 = GL_LINEAR, magFilter: Swift.Int32 = GL_LINEAR, wrapS: Swift.Int32 = GL_CLAMP_TO_EDGE, wrapT: Swift.Int32 = GL_CLAMP_TO_EDGE, internalFormat: Swift.Int32 = GL_RGBA, format: Swift.Int32 = GL_BGRA, type: Swift.Int32 = GL_UNSIGNED_BYTE, stencil: Swift.Bool = false) -> BVPSE.Framebuffer
  public func purgeAllUnassignedFramebuffers()
  @objc deinit
}
public class ShiTomasiFeatureDetector : BVPSE.HarrisCornerDetector {
  public init()
  @objc deinit
}
public class GaussianBlur : BVPSE.TwoStageOperation {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class StretchDistortion : BVPSE.BasicOperation {
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class CircleGenerator : BVPSE.ImageGenerator {
  override public init(size: BVPSE.Size)
  public func renderCircleOfRadius(_ radius: Swift.Float, center: BVPSE.Position, circleColor: BVPSE.Color = Color.white, backgroundColor: BVPSE.Color = Color.black)
  @objc deinit
}
public class RGBAdjustment : BVPSE.BasicOperation {
  public var red: Swift.Float {
    get
    set
  }
  public var blue: Swift.Float {
    get
    set
  }
  public var green: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class MotionBlur : BVPSE.BasicOperation {
  public var blurSize: Swift.Float
  public var blurAngle: Swift.Float
  public init()
  @objc deinit
}
public class SphereRefraction : BVPSE.BasicOperation {
  public var radius: Swift.Float {
    get
    set
  }
  public var refractiveIndex: Swift.Float {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public class RawDataOutput : BVPSE.ImageConsumer {
  public var dataAvailableCallback: (([Swift.UInt8], Swift.Int, Swift.Int, Swift.Int) -> ())?
  final public let sources: BVPSE.SourceContainer
  final public let maximumInputs: Swift.UInt
  public init()
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  @objc deinit
}
public class PinchDistortion : BVPSE.BasicOperation {
  public var radius: Swift.Float {
    get
    set
  }
  public var scale: Swift.Float {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class PerceptualStreamingEngine : ObjectiveC.NSObject {
  public var resultView: BVPSE.RenderViewMTL?
  @objc override dynamic public init()
  @objc deinit
  public func setSourceItem(sourceItem: AVFoundation.AVPlayerItem) -> Swift.Bool
  public func deleteSourceItem()
  public func setResultView(resultView: BVPSE.RenderViewMTL) -> Swift.Bool
  public func deleteResultView()
  public func enableDCCI(isEnable: Swift.Bool)
  public func enableSharpen(isEnable: Swift.Bool)
  public func enablePreAnime4k(isEnable: Swift.Bool)
  public func enablePostAnime4k(isEnable: Swift.Bool)
  public func startEvaluation(outputFolder: Swift.String) -> Swift.Bool
  public func stopEvaluation() -> Swift.Bool
  public func bypassEffect(isBypass: Swift.Bool)
  public func createPipeline(isEvaluation: Swift.Bool) -> Swift.Bool
  public func deletePipeline(isEvaluation: Swift.Bool) -> Swift.Bool
}
extension BVPSE.PerceptualStreamingEngine : BVPSE.VideoPlaybackInputDelegate {
  public func resolutionChanged(sender: Any, size: BVPSE.Size)
}
public class MultiplyBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class ColorBurnBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public func defaultVertexShaderForInputs(_ inputCount: Swift.UInt) -> Swift.String
open class BasicOperation : BVPSE.ImageProcessingOperation {
  final public let maximumInputs: Swift.UInt
  public var overriddenOutputSize: BVPSE.Size?
  public var overriddenOutputRotation: BVPSE.Rotation?
  public var backgroundColor: BVPSE.Color
  public var drawUnmodifiedImageOutsideOfMask: Swift.Bool
  public var mask: (any BVPSE.ImageSource)? {
    get
    set
  }
  public var activatePassthroughOnNextFrame: Swift.Bool
  public var uniformSettings: BVPSE.ShaderUniformSettings
  final public let targets: BVPSE.TargetContainer
  final public let sources: BVPSE.SourceContainer
  public init(shader: BVPSE.ShaderProgram, numberOfInputs: Swift.UInt = 1)
  public init(vertexShader: Swift.String? = nil, fragmentShader: Swift.String, numberOfInputs: Swift.UInt = 1, operationName: Swift.String = #file)
  public init(vertexShaderFile: Foundation.URL? = nil, fragmentShaderFile: Foundation.URL, numberOfInputs: Swift.UInt = 1, operationName: Swift.String = #file) throws
  @objc deinit
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func isBypass(isBypass: Swift.Bool)
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
}
@_inheritsConvenienceInitializers public class UnsharpMask : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var intensity: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class BulgeDistortion : BVPSE.BasicOperation {
  public var radius: Swift.Float {
    get
    set
  }
  public var scale: Swift.Float {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public class LookupFilter : BVPSE.BasicOperation {
  public var intensity: Swift.Float {
    get
    set
  }
  public var lookupImage: BVPSE.PictureInput? {
    get
    set
  }
  public init()
  @objc deinit
}
public class Dilation : BVPSE.TwoStageOperation {
  public var radius: Swift.UInt {
    get
    set
  }
  public init()
  @objc deinit
}
public class ThresholdSketchFilter : BVPSE.TextureSamplingOperation {
  public var edgeStrength: Swift.Float {
    get
    set
  }
  public var threshold: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class LevelsAdjustment : BVPSE.BasicOperation {
  public var minimum: BVPSE.Color {
    get
    set
  }
  public var middle: BVPSE.Color {
    get
    set
  }
  public var maximum: BVPSE.Color {
    get
    set
  }
  public var minOutput: BVPSE.Color {
    get
    set
  }
  public var maxOutput: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public class HistogramDisplay : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public protocol CameraDelegate {
  func didCaptureBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
}
public enum PhysicalCameraLocation {
  case backFacing
  case frontFacing
  public static func == (a: BVPSE.PhysicalCameraLocation, b: BVPSE.PhysicalCameraLocation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraError : Swift.Error {
}
@objc public class Camera : ObjectiveC.NSObject, BVPSE.ImageSource, AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate {
  public var location: BVPSE.PhysicalCameraLocation {
    get
    set
  }
  public var runBenchmark: Swift.Bool
  public var logFPS: Swift.Bool
  public var audioEncodingTarget: (any BVPSE.AudioEncodingTarget)? {
    get
    set
  }
  final public let targets: BVPSE.TargetContainer
  public var delegate: (any BVPSE.CameraDelegate)?
  final public let captureSession: AVFoundation.AVCaptureSession
  public init(sessionPreset: AVFoundation.AVCaptureSession.Preset, cameraDevice: AVFoundation.AVCaptureDevice? = nil, location: BVPSE.PhysicalCameraLocation = .backFacing, captureAsYUV: Swift.Bool = true) throws
  @objc deinit
  @objc public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  public func startCapture()
  public func stopCapture()
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
}
public class Solarize : BVPSE.BasicOperation {
  public var threshold: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class ColorBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class OpenGLContext : BVPSE.SerialDispatch {
  public var framebufferCache: BVPSE.FramebufferCache {
    get
    set
  }
  final public let standardImageVBO: OpenGLES.GLuint
  final public let serialDispatchQueue: Dispatch.DispatchQueue
  final public let dispatchQueueKey: Dispatch.DispatchSpecificKey<Swift.Int>
  public func makeCurrentContext()
  public var maximumTextureSizeForThisDevice: OpenGLES.GLint {
    get
  }
  public var maximumTextureUnitsForThisDevice: OpenGLES.GLint {
    get
  }
  public var maximumVaryingVectorsForThisDevice: OpenGLES.GLint {
    get
  }
  @objc deinit
}
public class DissolveBlend : BVPSE.BasicOperation {
  public var mix: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class PrewittEdgeDetection : BVPSE.TextureSamplingOperation {
  public var edgeStrength: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public let AdaptiveThresholdFragmentShader: Swift.String
public let AddBlendFragmentShader: Swift.String
public let AlphaBlendFragmentShader: Swift.String
public let AlphaTestFragmentShader: Swift.String
public let Anime4k_ComputeGradientFragmentShader: Swift.String
public let Anime4k_DetectLineFragmentShader: Swift.String
public let Anime4k_FxaaFragmentShader: Swift.String
public let Anime4k_Gaussian1D7FragmentShader: Swift.String
public let Anime4k_Gaussian1D7_HorizontalVertexShader: Swift.String
public let Anime4k_Gaussian1D7_VerticalVertexShader: Swift.String
public let Anime4k_GetLuminanceFragmentShader: Swift.String
public let Anime4k_PushLinesFragmentShader: Swift.String
public let Anime4k_PushThinLinesFragmentShader: Swift.String
public let Anime4k_YcbcrToRGBFragmentShader: Swift.String
public let AverageColorVertexShader: Swift.String
public let AverageColorFragmentShader: Swift.String
public let AverageLuminanceFragmentShader: Swift.String
public let BilateralBlurVertexShader: Swift.String
public let BilateralBlurFragmentShader: Swift.String
public let BrightnessFragmentShader: Swift.String
public let BulgeDistortionFragmentShader: Swift.String
public let CGAColorspaceFragmentShader: Swift.String
public let ChromaKeyBlendFragmentShader: Swift.String
public let ChromaKeyFragmentShader: Swift.String
public let CircleVertexShader: Swift.String
public let CircleFragmentShader: Swift.String
public let ColorBlendFragmentShader: Swift.String
public let ColorBurnBlendFragmentShader: Swift.String
public let ColorDodgeBlendFragmentShader: Swift.String
public let ColorInvertFragmentShader: Swift.String
public let ColorLocalBinaryPatternFragmentShader: Swift.String
public let ColorMatrixFragmentShader: Swift.String
public let ColorSwizzlingFragmentShader: Swift.String
public let ColourFASTDecriptorVertexShader: Swift.String
public let ColourFASTDecriptorFragmentShader: Swift.String
public let ContrastFragmentShader: Swift.String
public let Convolution3x3FragmentShader: Swift.String
public let CrosshairVertexShader: Swift.String
public let CrosshairFragmentShader: Swift.String
public let CrosshatchFragmentShader: Swift.String
public let DCCI_BottomLeftVertexShader: Swift.String
public let DCCI_BottomLeftFragmentShader: Swift.String
public let DCCI_BottomRightVertexShader: Swift.String
public let DCCI_BottomRightFragmentShader: Swift.String
public let DCCI_ComposeVertexShader: Swift.String
public let DCCI_ComposeFragmentShader: Swift.String
public let DCCI_TopRightVertexShader: Swift.String
public let DCCI_TopRightFragmentShader: Swift.String
public let DarkenBlendFragmentShader: Swift.String
public let DifferenceBlendFragmentShader: Swift.String
public let Dilation1FragmentShader: Swift.String
public let Dilation2FragmentShader: Swift.String
public let Dilation3FragmentShader: Swift.String
public let Dilation4FragmentShader: Swift.String
public let DirectionalNonMaximumSuppressionFragmentShader: Swift.String
public let DirectionalSobelEdgeDetectionFragmentShader: Swift.String
public let DissolveBlendFragmentShader: Swift.String
public let DivideBlendFragmentShader: Swift.String
public let Erosion1FragmentShader: Swift.String
public let Erosion2FragmentShader: Swift.String
public let Erosion3FragmentShader: Swift.String
public let Erosion4FragmentShader: Swift.String
public let ErosionDilation1VertexShader: Swift.String
public let ErosionDilation2VertexShader: Swift.String
public let ErosionDilation3VertexShader: Swift.String
public let ErosionDilation4VertexShader: Swift.String
public let ExclusionBlendFragmentShader: Swift.String
public let ExposureFragmentShader: Swift.String
public let FalseColorFragmentShader: Swift.String
public let FiveInputVertexShader: Swift.String
public let FourInputVertexShader: Swift.String
public let GammaFragmentShader: Swift.String
public let GlassSphereFragmentShader: Swift.String
public let HalftoneFragmentShader: Swift.String
public let HardLightBlendFragmentShader: Swift.String
public let HarrisCornerDetectorFragmentShader: Swift.String
public let HazeFragmentShader: Swift.String
public let HighlightShadowTintFragmentShader: Swift.String
public let HighlightShadowFragmentShader: Swift.String
public let HistogramAccumulationFragmentShader: Swift.String
public let HistogramBlueSamplingVertexShader: Swift.String
public let HistogramDisplayVertexShader: Swift.String
public let HistogramDisplayFragmentShader: Swift.String
public let HistogramEqualizationBlueFragmentShader: Swift.String
public let HistogramEqualizationGreenFragmentShader: Swift.String
public let HistogramEqualizationLuminanceFragmentShader: Swift.String
public let HistogramEqualizationRGBFragmentShader: Swift.String
public let HistogramEqualizationRedFragmentShader: Swift.String
public let HistogramGreenSamplingVertexShader: Swift.String
public let HistogramLuminanceSamplingVertexShader: Swift.String
public let HistogramRedSamplingVertexShader: Swift.String
public let HueBlendFragmentShader: Swift.String
public let HueFragmentShader: Swift.String
public let KuwaharaRadius3FragmentShader: Swift.String
public let KuwaharaFragmentShader: Swift.String
public let LanczosResamplingVertexShader: Swift.String
public let LanczosResamplingFragmentShader: Swift.String
public let LaplacianFragmentShader: Swift.String
public let LevelsFragmentShader: Swift.String
public let LightenBlendFragmentShader: Swift.String
public let LineVertexShader: Swift.String
public let LineFragmentShader: Swift.String
public let LinearBurnBlendFragmentShader: Swift.String
public let LocalBinaryPatternFragmentShader: Swift.String
public let LookupFragmentShader: Swift.String
public let LuminanceRangeFragmentShader: Swift.String
public let LuminanceThresholdFragmentShader: Swift.String
public let LuminanceFragmentShader: Swift.String
public let LuminosityBlendFragmentShader: Swift.String
public let MedianFragmentShader: Swift.String
public let MonochromeFragmentShader: Swift.String
public let MotionBlurVertexShader: Swift.String
public let MotionBlurFragmentShader: Swift.String
public let MotionComparisonFragmentShader: Swift.String
public let MultiplyBlendFragmentShader: Swift.String
public let NearbyTexelSamplingVertexShader: Swift.String
public let NobleCornerDetectorFragmentShader: Swift.String
public let NormalBlendFragmentShader: Swift.String
public let OneInputVertexShader: Swift.String
public let OpacityFragmentShader: Swift.String
public let OverlayBlendFragmentShader: Swift.String
public let PassthroughFragmentShader: Swift.String
public let PinchDistortionFragmentShader: Swift.String
public let PixellateFragmentShader: Swift.String
public let PolarPixellateFragmentShader: Swift.String
public let PolkaDotFragmentShader: Swift.String
public let PosterizeFragmentShader: Swift.String
public let PrewittEdgeDetectionFragmentShader: Swift.String
public let RGBAdjustmentFragmentShader: Swift.String
public let SaturationBlendFragmentShader: Swift.String
public let SaturationFragmentShader: Swift.String
public let ScreenBlendFragmentShader: Swift.String
public let SharpenVertexShader: Swift.String
public let SharpenFragmentShader: Swift.String
public let ShiTomasiFeatureDetectorFragmentShader: Swift.String
public let SketchFragmentShader: Swift.String
public let SobelEdgeDetectionFragmentShader: Swift.String
public let SoftLightBlendFragmentShader: Swift.String
public let SolarizeFragmentShader: Swift.String
public let SourceOverBlendFragmentShader: Swift.String
public let SphereRefractionFragmentShader: Swift.String
public let StretchDistortionFragmentShader: Swift.String
public let SubtractBlendFragmentShader: Swift.String
public let SwirlFragmentShader: Swift.String
public let ThreeInputVertexShader: Swift.String
public let ThresholdEdgeDetectionFragmentShader: Swift.String
public let ThresholdSketchFragmentShader: Swift.String
public let ThresholdedNonMaximumSuppressionFragmentShader: Swift.String
public let TiltShiftFragmentShader: Swift.String
public let ToonFragmentShader: Swift.String
public let TransformVertexShader: Swift.String
public let TwoInputVertexShader: Swift.String
public let UnsharpMaskFragmentShader: Swift.String
public let VibranceFragmentShader: Swift.String
public let VignetteFragmentShader: Swift.String
public let WeakPixelInclusionFragmentShader: Swift.String
public let WhiteBalanceFragmentShader: Swift.String
public let XYDerivativeFragmentShader: Swift.String
public let YUVConversionFullRangeUVPlanarFragmentShader: Swift.String
public let YUVConversionFullRangeFragmentShader: Swift.String
public let YUVConversionVideoRangeFragmentShader: Swift.String
public let ZoomBlurFragmentShader: Swift.String
public class SoftLightBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public struct Color {
  public let redComponent: Swift.Float
  public let greenComponent: Swift.Float
  public let blueComponent: Swift.Float
  public let alphaComponent: Swift.Float
  public init(red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float = 1.0)
  public static let black: BVPSE.Color
  public static let white: BVPSE.Color
  public static let red: BVPSE.Color
  public static let green: BVPSE.Color
  public static let blue: BVPSE.Color
  public static let transparent: BVPSE.Color
}
public class AverageColorExtractor : BVPSE.BasicOperation {
  public var extractedColorCallback: ((BVPSE.Color) -> ())?
  public init()
  @objc deinit
}
public class LuminanceRangeReduction : BVPSE.BasicOperation {
  public var rangeReductionFactor: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class SwirlDistortion : BVPSE.BasicOperation {
  public var radius: Swift.Float {
    get
    set
  }
  public var angle: Swift.Float {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public enum FramebufferTimingStyle {
  case stillImage
  case videoFrame(timestamp: BVPSE.Timestamp)
}
public class Framebuffer {
  public var timingStyle: BVPSE.FramebufferTimingStyle
  public var orientation: BVPSE.ImageOrientation
  final public let texture: OpenGLES.GLuint
  final public let size: BVPSE.GLSize
  public init(context: BVPSE.OpenGLContext, orientation: BVPSE.ImageOrientation, size: BVPSE.GLSize, textureOnly: Swift.Bool = false, minFilter: Swift.Int32 = GL_LINEAR, magFilter: Swift.Int32 = GL_LINEAR, wrapS: Swift.Int32 = GL_CLAMP_TO_EDGE, wrapT: Swift.Int32 = GL_CLAMP_TO_EDGE, internalFormat: Swift.Int32 = GL_RGBA, format: Swift.Int32 = GL_BGRA, type: Swift.Int32 = GL_UNSIGNED_BYTE, stencil: Swift.Bool = false, overriddenTexture: OpenGLES.GLuint? = nil) throws
  @objc deinit
  public func texelSize(for rotation: BVPSE.Rotation) -> BVPSE.Size
  public func texturePropertiesForOutputRotation(_ rotation: BVPSE.Rotation) -> BVPSE.InputTextureProperties
  public func texturePropertiesForTargetOrientation(_ targetOrientation: BVPSE.ImageOrientation) -> BVPSE.InputTextureProperties
  public func activateFramebufferForRendering()
  public func lock()
  public func unlock()
}
extension BVPSE.Size {
  public func glWidth() -> OpenGLES.GLint
  public func glHeight() -> OpenGLES.GLint
}
@_inheritsConvenienceInitializers public class EmbossFilter : BVPSE.Convolution3x3 {
  public var intensity: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public struct ShaderUniformSettings {
  public init()
  public subscript(index: Swift.String) -> Swift.Float? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> Swift.Int? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> BVPSE.Color? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> BVPSE.Position? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> BVPSE.Size? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> BVPSE.Matrix4x4? {
    get
    set(newValue)
  }
  public subscript(index: Swift.String) -> BVPSE.Matrix3x3? {
    get
    set(newValue)
  }
  public func restoreShaderSettings(_ shader: BVPSE.ShaderProgram)
}
extension BVPSE.Matrix3x3 {
  public func toRowMajorGLArray() -> [OpenGLES.GLfloat]
}
public class CGAColorspaceFilter : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class ColorDodgeBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class TransformOperation : BVPSE.BasicOperation {
  public var transform: BVPSE.Matrix4x4 {
    get
    set
  }
  public init()
  @objc deinit
}
public class Crop : BVPSE.BasicOperation {
  public var cropSizeInPixels: BVPSE.Size?
  public var locationOfCropInPixels: BVPSE.Position?
  public init()
  @objc deinit
}
public var standardProcessingQueue: Dispatch.DispatchQueue {
  get
}
public var lowProcessingQueue: Dispatch.DispatchQueue {
  get
}
public protocol SerialDispatch {
  var serialDispatchQueue: Dispatch.DispatchQueue { get }
  var dispatchQueueKey: Dispatch.DispatchSpecificKey<Swift.Int> { get }
  func makeCurrentContext()
}
extension BVPSE.SerialDispatch {
  public func runOperationAsynchronously(_ operation: @escaping () -> ())
  public func runOperationSynchronously(_ operation: () -> ())
  public func runOperationSynchronously(_ operation: () throws -> ()) throws
  public func runOperationSynchronously<T>(_ operation: () throws -> T) throws -> T
  public func runOperationSynchronously<T>(_ operation: () -> T) -> T
}
public class ExposureAdjustment : BVPSE.BasicOperation {
  public var exposure: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Laplacian : BVPSE.TextureSamplingOperation {
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class TiltShift : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var topFocusLevel: Swift.Float {
    get
    set
  }
  public var bottomFocusLevel: Swift.Float {
    get
    set
  }
  public var focusFallOffRate: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class SoftElegance : BVPSE.OperationGroup {
  override public init()
  @objc deinit
}
public class HighlightAndShadowTint : BVPSE.BasicOperation {
  public var shadowTintIntensity: Swift.Float {
    get
    set
  }
  public var highlightTintIntensity: Swift.Float {
    get
    set
  }
  public var shadowTintColor: BVPSE.Color {
    get
    set
  }
  public var highlightTintColor: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public class BilateralBlur : BVPSE.TwoStageOperation {
  public var distanceNormalizationFactor: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class ClosingFilter : BVPSE.OperationGroup {
  public var radius: Swift.UInt {
    get
    set
  }
  override public init()
  @objc deinit
}
public class TextureInput : BVPSE.ImageSource {
  final public let targets: BVPSE.TargetContainer
  public init(texture: OpenGLES.GLuint, size: BVPSE.Size, orientation: BVPSE.ImageOrientation = .portrait)
  public func processTexture()
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class AlphaBlend : BVPSE.BasicOperation {
  public var mix: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class OpacityAdjustment : BVPSE.BasicOperation {
  public var opacity: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class DivideBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class DifferenceBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class MedianFilter : BVPSE.TextureSamplingOperation {
  public init()
  @objc deinit
}
public struct Position {
  public let x: Swift.Float
  public let y: Swift.Float
  public let z: Swift.Float?
  public init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float? = nil)
  public init(point: CoreFoundation.CGPoint)
  public static let center: BVPSE.Position
  public static let zero: BVPSE.Position
}
public class ChromaKeyBlend : BVPSE.BasicOperation {
  public var thresholdSensitivity: Swift.Float {
    get
    set
  }
  public var smoothing: Swift.Float {
    get
    set
  }
  public var colorToReplace: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public class PictureInput : BVPSE.ImageSource {
  final public let targets: BVPSE.TargetContainer
  public init(image: CoreGraphics.CGImage, smoothlyScaleOutput: Swift.Bool = false, orientation: BVPSE.ImageOrientation = .portrait)
  convenience public init(image: UIKit.UIImage, smoothlyScaleOutput: Swift.Bool = false, orientation: BVPSE.ImageOrientation = .portrait)
  convenience public init(imageName: Swift.String, smoothlyScaleOutput: Swift.Bool = false, orientation: BVPSE.ImageOrientation = .portrait)
  public func processImage(synchronously: Swift.Bool = false)
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class Luminance : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class AddBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class ChromaKeying : BVPSE.BasicOperation {
  public var thresholdSensitivity: Swift.Float {
    get
    set
  }
  public var smoothing: Swift.Float {
    get
    set
  }
  public var colorToReplace: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public struct Size {
  public let width: Swift.Float
  public let height: Swift.Float
  public init(width: Swift.Float, height: Swift.Float)
}
public enum FillMode {
  case stretch
  case preserveAspectRatio
  case preserveAspectRatioAndFill
  public static func == (a: BVPSE.FillMode, b: BVPSE.FillMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class RenderView : UIKit.UIView, BVPSE.ImageConsumer {
  @_Concurrency.MainActor(unsafe) public var backgroundRenderColor: BVPSE.Color
  @_Concurrency.MainActor(unsafe) public var fillMode: BVPSE.FillMode
  @_Concurrency.MainActor(unsafe) public var orientation: BVPSE.ImageOrientation
  @_Concurrency.MainActor(unsafe) public var sizeInPixels: BVPSE.Size {
    get
  }
  @_Concurrency.MainActor(unsafe) final public let sources: BVPSE.SourceContainer
  @_Concurrency.MainActor(unsafe) final public let maximumInputs: Swift.UInt
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func reallocateDisplayFramebuffer()
  @_Concurrency.MainActor(unsafe) public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
}
public class BrightnessAdjustment : BVPSE.BasicOperation {
  public var brightness: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class DCCI : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class KuwaharaRadius3Filter : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public protocol VideoPlaybackInputDelegate : AnyObject {
  func resolutionChanged(sender: Any, size: BVPSE.Size)
}
@objc public class VideoPlaybackInput : ObjectiveC.NSObject, BVPSE.ImageSource {
  final public let targets: BVPSE.TargetContainer
  weak public var delegate: (any BVPSE.VideoPlaybackInputDelegate)?
  public var runBenchmark: Swift.Bool
  public init(playerItem: AVFoundation.AVPlayerItem) throws
  @objc deinit
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
}
extension BVPSE.VideoPlaybackInput : AVFoundation.AVPlayerItemOutputPullDelegate {
  @available(iOS 6.0, *)
  @objc dynamic public func outputMediaDataWillChange(_ sender: AVFoundation.AVPlayerItemOutput)
}
public class SubtractBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class LanczosResampling : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class SaturationAdjustment : BVPSE.BasicOperation {
  public var saturation: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Pixellate : BVPSE.BasicOperation {
  public var fractionalWidthOfAPixel: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public struct TimestampFlags : Swift.OptionSet {
  public let rawValue: Swift.UInt32
  public init(rawValue: Swift.UInt32)
  public static let valid: BVPSE.TimestampFlags
  public static let hasBeenRounded: BVPSE.TimestampFlags
  public static let positiveInfinity: BVPSE.TimestampFlags
  public static let negativeInfinity: BVPSE.TimestampFlags
  public static let indefinite: BVPSE.TimestampFlags
  public typealias ArrayLiteralElement = BVPSE.TimestampFlags
  public typealias Element = BVPSE.TimestampFlags
  public typealias RawValue = Swift.UInt32
}
public struct Timestamp : Swift.Comparable {
  public init(value: Swift.Int64, timescale: Swift.Int32, flags: BVPSE.TimestampFlags, epoch: Swift.Int64)
}
public func == (x: BVPSE.Timestamp, y: BVPSE.Timestamp) -> Swift.Bool
public func < (x: BVPSE.Timestamp, y: BVPSE.Timestamp) -> Swift.Bool
public enum TextureTimingStyle {
  case stillImage
  case videoFrame(timestamp: BVPSE.Timestamp)
}
public class Texture {
  public var timingStyle: BVPSE.TextureTimingStyle
  public var orientation: BVPSE.ImageOrientation
  final public let texture: any Metal.MTLTexture
  public init(orientation: BVPSE.ImageOrientation, texture: any Metal.MTLTexture, timingStyle: BVPSE.TextureTimingStyle = .stillImage)
  public init(device: any Metal.MTLDevice, orientation: BVPSE.ImageOrientation, pixelFormat: Metal.MTLPixelFormat = .bgra8Unorm, width: Swift.Int, height: Swift.Int, mipmapped: Swift.Bool = false, timingStyle: BVPSE.TextureTimingStyle = .stillImage)
  @objc deinit
}
public class ColorMatrixFilter : BVPSE.BasicOperation {
  public var intensity: Swift.Float {
    get
    set
  }
  public var colorMatrix: BVPSE.Matrix4x4 {
    get
    set
  }
  public init()
  @objc deinit
}
public class ScreenBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class Haze : BVPSE.BasicOperation {
  public var distance: Swift.Float {
    get
    set
  }
  public var slope: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class SourceOverBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public let sharedMetalRenderingDevice: BVPSE.MetalRenderingDevice
@_hasMissingDesignatedInitializers public class MetalRenderingDevice {
  final public let device: any Metal.MTLDevice
  final public let commandQueue: any Metal.MTLCommandQueue
  final public let shaderLibrary: any Metal.MTLLibrary
  final public let metalPerformanceShadersAreSupported: Swift.Bool
  @objc deinit
}
public class Vibrance : BVPSE.BasicOperation {
  public var vibrance: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class ShaderUniformSettingsMTL {
  public var colorUniformsUseAlpha: Swift.Bool
  public init(uniformLookupTable: [Swift.String : (Swift.Int, Metal.MTLDataType)])
  public var usesAspectRatio: Swift.Bool {
    get
  }
  public subscript(key: Swift.String) -> Swift.Float {
    get
    set(newValue)
  }
  public subscript(key: Swift.String) -> BVPSE.Color {
    get
    set(newValue)
  }
  public subscript(key: Swift.String) -> BVPSE.Position {
    get
    set(newValue)
  }
  public subscript(key: Swift.String) -> BVPSE.Size {
    get
    set(newValue)
  }
  public subscript(key: Swift.String) -> BVPSE.Matrix3x3 {
    get
    set(newValue)
  }
  public subscript(key: Swift.String) -> BVPSE.Matrix4x4 {
    get
    set(newValue)
  }
  public func restoreShaderSettings(renderEncoder: any Metal.MTLRenderCommandEncoder)
  @objc deinit
}
public protocol UniformConvertible {
  func toFloatArray() -> [Swift.Float]
}
extension Swift.Float : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
extension Swift.Double : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
extension BVPSE.Position : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
extension BVPSE.Matrix3x3 : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
extension BVPSE.Matrix4x4 : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
extension BVPSE.Size : BVPSE.UniformConvertible {
  public func toFloatArray() -> [Swift.Float]
}
@_inheritsConvenienceInitializers public class SolidColorGenerator : BVPSE.ImageGenerator {
  public func renderColor(_ color: BVPSE.Color)
  override public init(size: BVPSE.Size)
  @objc deinit
}
public class FalseColor : BVPSE.BasicOperation {
  public var firstColor: BVPSE.Color {
    get
    set
  }
  public var secondColor: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public class ThresholdSobelEdgeDetection : BVPSE.TextureSamplingOperation {
  public var edgeStrength: Swift.Float {
    get
    set
  }
  public var threshold: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class HighlightsAndShadows : BVPSE.BasicOperation {
  public var shadows: Swift.Float {
    get
    set
  }
  public var highlights: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Halftone : BVPSE.BasicOperation {
  public var fractionalWidthOfAPixel: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ImageBuffer : BVPSE.ImageProcessingOperation {
  public var bufferSize: Swift.UInt
  public var activatePassthroughOnNextFrame: Swift.Bool
  final public let maximumInputs: Swift.UInt
  final public let targets: BVPSE.TargetContainer
  final public let sources: BVPSE.SourceContainer
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class LocalBinaryPattern : BVPSE.TextureSamplingOperation {
  public init()
  @objc deinit
}
public class ExclusionBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class KuwaharaFilter : BVPSE.BasicOperation {
  public var radius: Swift.Int {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class CrosshairGenerator : BVPSE.ImageGenerator {
  public var crosshairWidth: Swift.Float {
    get
    set
  }
  public var crosshairColor: BVPSE.Color {
    get
    set
  }
  override public init(size: BVPSE.Size)
  public func renderCrosshairs(_ positions: [BVPSE.Position])
  @objc deinit
}
@_inheritsConvenienceInitializers public class SmoothToonFilter : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var threshold: Swift.Float {
    get
    set
  }
  public var quantizationLevels: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class LuminanceThreshold : BVPSE.BasicOperation {
  public var threshold: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class PolarPixellate : BVPSE.BasicOperation {
  public var pixelSize: BVPSE.Size {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public class SobelEdgeDetection : BVPSE.TextureSamplingOperation {
  public var edgeStrength: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class AdaptiveThreshold : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class SketchFilter : BVPSE.TextureSamplingOperation {
  public var edgeStrength: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Bilinear : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class NormalBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class HighPassFilter : BVPSE.OperationGroup {
  public var strength: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
open class TextureSamplingOperation : BVPSE.BasicOperation {
  public var overriddenTexelSize: BVPSE.Size?
  public init(vertexShader: Swift.String = NearbyTexelSamplingVertexShader, fragmentShader: Swift.String, numberOfInputs: Swift.UInt = 1)
  @objc deinit
}
public class OverlayBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class MovieInput : BVPSE.ImageSource {
  final public let targets: BVPSE.TargetContainer
  public var runBenchmark: Swift.Bool
  public init(asset: AVFoundation.AVAsset, playAtActualSpeed: Swift.Bool = false, loop: Swift.Bool = false) throws
  convenience public init(url: Foundation.URL, playAtActualSpeed: Swift.Bool = false, loop: Swift.Bool = false) throws
  public func start()
  public func cancel()
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class MonochromeFilter : BVPSE.BasicOperation {
  public var intensity: Swift.Float {
    get
    set
  }
  public var color: BVPSE.Color {
    get
    set
  }
  public init()
  @objc deinit
}
public class Posterize : BVPSE.BasicOperation {
  public var colorLevels: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class iOSBlur : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  public var saturation: Swift.Float {
    get
    set
  }
  public var rangeReductionFactor: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class ColourFASTFeatureDetection : BVPSE.OperationGroup {
  public var blurRadiusInPixels: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class ContrastAdjustment : BVPSE.BasicOperation {
  public var contrast: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public enum HistogramType {
  case red
  case blue
  case green
  case luminance
  case rgb
  public static func == (a: BVPSE.HistogramType, b: BVPSE.HistogramType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class Histogram : BVPSE.BasicOperation {
  public var downsamplingFactor: Swift.UInt
  public init(type: BVPSE.HistogramType)
  @objc deinit
}
@_inheritsConvenienceInitializers public class LowPassFilter : BVPSE.OperationGroup {
  public var strength: Swift.Float {
    get
    set
  }
  override public init()
  @objc deinit
}
public class HueAdjustment : BVPSE.BasicOperation {
  public var hue: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class HueBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public class Crosshatch : BVPSE.BasicOperation {
  public var crossHatchSpacing: Swift.Float {
    get
    set
  }
  public var lineWidth: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public enum PictureFileFormat {
  case png
  case jpeg
  public static func == (a: BVPSE.PictureFileFormat, b: BVPSE.PictureFileFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class PictureOutput : BVPSE.ImageConsumer {
  public var encodedImageAvailableCallback: ((Foundation.Data) -> ())?
  public var encodedImageFormat: BVPSE.PictureFileFormat
  public var imageAvailableCallback: ((UIKit.UIImage) -> ())?
  public var onlyCaptureNextFrame: Swift.Bool
  public var keepImageAroundForSynchronousCapture: Swift.Bool
  final public let sources: BVPSE.SourceContainer
  final public let maximumInputs: Swift.UInt
  public init()
  @objc deinit
  public func saveNextFrameToURL(_ url: Foundation.URL, format: BVPSE.PictureFileFormat)
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func synchronousImageCapture() -> UIKit.UIImage
}
extension BVPSE.ImageSource {
  public func saveNextFrameToURL(_ url: Foundation.URL, format: BVPSE.PictureFileFormat)
}
extension UIKit.UIImage {
  public func filterWithOperation<T>(_ operation: T) -> UIKit.UIImage where T : BVPSE.ImageProcessingOperation
  public func filterWithPipeline(_ pipeline: (BVPSE.PictureInput, BVPSE.PictureOutput) -> ()) -> UIKit.UIImage
}
public class LightenBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public protocol AudioEncodingTarget {
  func activateAudioTrack()
  func processAudioBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
}
public class MovieOutput : BVPSE.ImageConsumer, BVPSE.AudioEncodingTarget {
  final public let sources: BVPSE.SourceContainer
  final public let maximumInputs: Swift.UInt
  public init(URL: Foundation.URL, size: BVPSE.Size, fileType: AVFoundation.AVFileType = AVFileType.mov, liveVideo: Swift.Bool = false, settings: [Swift.String : Any]? = nil) throws
  public func startRecording()
  public func finishRecording(_ completionCallback: (() -> Swift.Void)? = nil)
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func activateAudioTrack()
  public func processAudioBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
  @objc deinit
}
extension BVPSE.Timestamp {
  public init(_ time: CoreMedia.CMTime)
  public var asCMTime: CoreMedia.CMTime {
    get
  }
}
public class ColorInversion : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
open class OperationGroup : BVPSE.ImageProcessingOperation {
  public var sources: BVPSE.SourceContainer {
    get
  }
  public var targets: BVPSE.TargetContainer {
    get
  }
  final public let maximumInputs: Swift.UInt
  public init()
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func configureGroup(_ configurationOperation: (_ input: BVPSE.ImageRelay, _ output: BVPSE.ImageRelay) -> ())
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public enum InputTextureStorageFormat {
  case textureCoordinates([OpenGLES.GLfloat])
  case textureVBO(OpenGLES.GLuint)
}
public struct InputTextureProperties {
  public let textureStorage: BVPSE.InputTextureStorageFormat
  public let texture: OpenGLES.GLuint
  public init(textureCoordinates: [OpenGLES.GLfloat]? = nil, textureVBO: OpenGLES.GLuint? = nil, texture: OpenGLES.GLuint)
}
public struct GLSize {
  public let width: OpenGLES.GLint
  public let height: OpenGLES.GLint
  public init(width: OpenGLES.GLint, height: OpenGLES.GLint)
  public init(_ size: BVPSE.Size)
}
public let standardImageVertices: [OpenGLES.GLfloat]
public let verticallyInvertedImageVertices: [OpenGLES.GLfloat]
public func renderQuadWithShader(_ shader: BVPSE.ShaderProgram, uniformSettings: BVPSE.ShaderUniformSettings? = nil, vertices: [OpenGLES.GLfloat]? = nil, vertexBufferObject: OpenGLES.GLuint? = nil, inputTextures: [BVPSE.InputTextureProperties])
public func clearFramebufferWithColor(_ color: BVPSE.Color)
public func generateTexture(minFilter: Swift.Int32, magFilter: Swift.Int32, wrapS: Swift.Int32, wrapT: Swift.Int32) -> OpenGLES.GLuint
public func uploadLocalArray(data: [OpenGLES.GLfloat], into texture: OpenGLES.GLuint, size: BVPSE.GLSize)
public func enableAdditiveBlending()
public func disableBlending()
public func generateVBO(for vertices: [OpenGLES.GLfloat]) -> OpenGLES.GLuint
public func deleteVBO(_ vbo: OpenGLES.GLuint)
public class ToonFilter : BVPSE.TextureSamplingOperation {
  public var threshold: Swift.Float {
    get
    set
  }
  public var quantizationLevels: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public enum PixelFormat {
  case bgra
  case rgba
  case rgb
  case luminance
  public static func == (a: BVPSE.PixelFormat, b: BVPSE.PixelFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class RawDataInput : BVPSE.ImageSource {
  final public let targets: BVPSE.TargetContainer
  public init()
  public func uploadBytes(_ bytes: [Swift.UInt8], size: BVPSE.Size, pixelFormat: BVPSE.PixelFormat, orientation: BVPSE.ImageOrientation = .portrait)
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class GammaAdjustment : BVPSE.BasicOperation {
  public var gamma: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Vignette : BVPSE.BasicOperation {
  public var center: BVPSE.Position {
    get
    set
  }
  public var color: BVPSE.Color {
    get
    set
  }
  public var start: Swift.Float {
    get
    set
  }
  public var end: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TextureOutput : BVPSE.ImageConsumer {
  public var newTextureAvailableCallback: ((OpenGLES.GLuint) -> ())?
  final public let sources: BVPSE.SourceContainer
  final public let maximumInputs: Swift.UInt
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  @objc deinit
}
public class ColorLocalBinaryPattern : BVPSE.TextureSamplingOperation {
  public init()
  @objc deinit
}
public class AverageLuminanceExtractor : BVPSE.BasicOperation {
  public var extractedLuminanceCallback: ((Swift.Float) -> ())?
  public init()
  @objc deinit
}
public class PolkaDot : BVPSE.BasicOperation {
  public var dotScaling: Swift.Float {
    get
    set
  }
  public var fractionalWidthOfAPixel: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public struct Matrix4x4 {
  public let m11: Swift.Float, m12: Swift.Float, m13: Swift.Float, m14: Swift.Float
  public let m21: Swift.Float, m22: Swift.Float, m23: Swift.Float, m24: Swift.Float
  public let m31: Swift.Float, m32: Swift.Float, m33: Swift.Float, m34: Swift.Float
  public let m41: Swift.Float, m42: Swift.Float, m43: Swift.Float, m44: Swift.Float
  public init(rowMajorValues: [Swift.Float])
  public static let identity: BVPSE.Matrix4x4
}
public struct Matrix3x3 {
  public let m11: Swift.Float, m12: Swift.Float, m13: Swift.Float
  public let m21: Swift.Float, m22: Swift.Float, m23: Swift.Float
  public let m31: Swift.Float, m32: Swift.Float, m33: Swift.Float
  public init(rowMajorValues: [Swift.Float])
  public static let identity: BVPSE.Matrix3x3
  public static let centerOnly: BVPSE.Matrix3x3
}
extension BVPSE.Matrix4x4 {
  public init(_ transform3D: QuartzCore.CATransform3D)
  public init(_ transform: CoreFoundation.CGAffineTransform)
}
@_inheritsConvenienceInitializers public class MotionDetector : BVPSE.OperationGroup {
  public var lowPassStrength: Swift.Float {
    get
    set
  }
  public var motionDetectedCallback: ((BVPSE.Position, Swift.Float) -> ())?
  override public init()
  @objc deinit
}
public class SaturationBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public let colorConversionMatrix601Default: BVPSE.Matrix3x3
public let colorConversionMatrix601FullRangeDefault: BVPSE.Matrix3x3
public let colorConversionMatrix709Default: BVPSE.Matrix3x3
public func convertYUVToRGB(shader: BVPSE.ShaderProgram, luminanceFramebuffer: BVPSE.Framebuffer, chrominanceFramebuffer: BVPSE.Framebuffer, secondChrominanceFramebuffer: BVPSE.Framebuffer? = nil, resultFramebuffer: BVPSE.Framebuffer, colorConversionMatrix: BVPSE.Matrix3x3)
public class ShaderProgram {
  public var colorUniformsUseFourComponents: Swift.Bool
  public init(vertexShader: Swift.String, fragmentShader: Swift.String) throws
  convenience public init(vertexShader: Swift.String, fragmentShaderFile: Foundation.URL) throws
  convenience public init(vertexShaderFile: Foundation.URL, fragmentShaderFile: Foundation.URL) throws
  @objc deinit
  public func attributeIndex(_ attribute: Swift.String) -> OpenGLES.GLuint?
  public func uniformIndex(_ uniform: Swift.String) -> OpenGLES.GLint?
  public func setValue(_ value: OpenGLES.GLfloat, forUniform: Swift.String)
  public func setValue(_ value: OpenGLES.GLint, forUniform: Swift.String)
  public func setValue(_ value: BVPSE.Color, forUniform: Swift.String)
  public func setValue(_ value: [OpenGLES.GLfloat], forUniform: Swift.String)
  public func setMatrix(_ value: [OpenGLES.GLfloat], forUniform: Swift.String)
  public func use()
}
public func crashOnShaderCompileFailure<T>(_ shaderName: Swift.String, _ operation: () throws -> T) -> T
public func shaderFromFile(_ file: Foundation.URL) throws -> Swift.String
public class NobleCornerDetector : BVPSE.HarrisCornerDetector {
  public init()
  @objc deinit
}
public class ZoomBlur : BVPSE.BasicOperation {
  public var blurSize: Swift.Float {
    get
    set
  }
  public var blurCenter: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public protocol ImageSource {
  var targets: BVPSE.TargetContainer { get }
  func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
}
public protocol ImageConsumer : AnyObject {
  var maximumInputs: Swift.UInt { get }
  var sources: BVPSE.SourceContainer { get }
  func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
}
public protocol ImageProcessingOperation : BVPSE.ImageConsumer, BVPSE.ImageSource {
}
infix operator --> : AdditionPrecedence
@discardableResult
public func --> <T>(source: any BVPSE.ImageSource, destination: T) -> T where T : BVPSE.ImageConsumer
extension BVPSE.ImageSource {
  public func addTarget(_ target: any BVPSE.ImageConsumer, atTargetIndex: Swift.UInt? = nil)
  public func removeAllTargets()
  public func updateTargetsWithFramebuffer(_ framebuffer: BVPSE.Framebuffer)
}
extension BVPSE.ImageConsumer {
  public func addSource(_ source: any BVPSE.ImageSource) -> Swift.UInt?
  public func setSource(_ source: any BVPSE.ImageSource, atIndex: Swift.UInt)
  public func removeSourceAtIndex(_ index: Swift.UInt)
}
public class TargetContainer : Swift.Sequence {
  public init()
  public func append(_ target: any BVPSE.ImageConsumer, indexAtTarget: Swift.UInt)
  public func makeIterator() -> Swift.AnyIterator<(any BVPSE.ImageConsumer, Swift.UInt)>
  public func removeAll()
  public typealias Element = (any BVPSE.ImageConsumer, Swift.UInt)
  public typealias Iterator = Swift.AnyIterator<(any BVPSE.ImageConsumer, Swift.UInt)>
  @objc deinit
}
public class SourceContainer {
  public init()
  public func append(_ source: any BVPSE.ImageSource, maximumInputs: Swift.UInt) -> Swift.UInt?
  public func insert(_ source: any BVPSE.ImageSource, atIndex: Swift.UInt, maximumInputs: Swift.UInt) -> Swift.UInt
  public func removeAtIndex(_ index: Swift.UInt)
  @objc deinit
}
public class ImageRelay : BVPSE.ImageProcessingOperation {
  public var newImageCallback: ((BVPSE.Framebuffer) -> ())?
  final public let sources: BVPSE.SourceContainer
  final public let targets: BVPSE.TargetContainer
  final public let maximumInputs: Swift.UInt
  public var preventRelay: Swift.Bool
  public init()
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  public func newFramebufferAvailable(_ framebuffer: BVPSE.Framebuffer, fromSourceIndex: Swift.UInt)
  public func relayFramebufferOnward(_ framebuffer: BVPSE.Framebuffer)
  @objc deinit
}
public enum Line {
  case infinite(slope: Swift.Float, intercept: Swift.Float)
  case segment(p1: BVPSE.Position, p2: BVPSE.Position)
}
@_inheritsConvenienceInitializers public class LineGenerator : BVPSE.ImageGenerator {
  public var lineColor: BVPSE.Color {
    get
    set
  }
  public var lineWidth: Swift.Float {
    get
    set
  }
  override public init(size: BVPSE.Size)
  public func renderLines(_ lines: [BVPSE.Line])
  @objc deinit
}
public class HistogramEqualization : BVPSE.OperationGroup {
  public var downsamplingFactor: Swift.UInt {
    get
    set
  }
  public init(type: BVPSE.HistogramType)
  @objc deinit
}
@_inheritsConvenienceInitializers public class AmatorkaFilter : BVPSE.LookupFilter {
  override public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class OpeningFilter : BVPSE.OperationGroup {
  public var radius: Swift.UInt {
    get
    set
  }
  override public init()
  @objc deinit
}
public class LuminosityBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
public let standardImageVerticesMTL: [Swift.Float]
public class Anime4k : BVPSE.BasicOperation {
  public var pushThinLineStrength: Swift.Float
  public var pushLineStrength: Swift.Float
  public var lineDetectThreshold: Swift.Float
  public init()
  @objc deinit
}
public class ImageGenerator : BVPSE.ImageSource {
  public var size: BVPSE.Size
  final public let targets: BVPSE.TargetContainer
  public init(size: BVPSE.Size)
  public func transmitPreviousImage(to target: any BVPSE.ImageConsumer, atIndex: Swift.UInt)
  @objc deinit
}
public class GlassSphereRefraction : BVPSE.BasicOperation {
  public var radius: Swift.Float {
    get
    set
  }
  public var refractiveIndex: Swift.Float {
    get
    set
  }
  public var center: BVPSE.Position {
    get
    set
  }
  public init()
  @objc deinit
}
public class Sharpen : BVPSE.BasicOperation {
  public var sharpness: Swift.Float {
    get
    set
  }
  public var overriddenTexelSize: BVPSE.Size?
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class SepiaToneFilter : BVPSE.ColorMatrixFilter {
  override public init()
  @objc deinit
}
public class WhiteBalance : BVPSE.BasicOperation {
  public var temperature: Swift.Float {
    get
    set
  }
  public var tint: Swift.Float {
    get
    set
  }
  public init()
  @objc deinit
}
public class Convolution3x3 : BVPSE.TextureSamplingOperation {
  public var convolutionKernel: BVPSE.Matrix3x3 {
    get
    set
  }
  public init()
  @objc deinit
}
public class Erosion : BVPSE.TwoStageOperation {
  public var radius: Swift.UInt {
    get
    set
  }
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class AverageLuminanceThreshold : BVPSE.OperationGroup {
  public var thresholdMultiplier: Swift.Float
  override public init()
  @objc deinit
}
public let sharedImageProcessingContext: BVPSE.OpenGLContext
extension BVPSE.OpenGLContext {
  public func programForVertexShader(_ vertexShader: Swift.String, fragmentShader: Swift.String) throws -> BVPSE.ShaderProgram
  public func programForVertexShader(_ vertexShader: Swift.String, fragmentShader: Foundation.URL) throws -> BVPSE.ShaderProgram
  public func programForVertexShader(_ vertexShader: Foundation.URL, fragmentShader: Foundation.URL) throws -> BVPSE.ShaderProgram
  public func openGLDeviceSettingForOption(_ option: Swift.Int32) -> OpenGLES.GLint
  public func deviceSupportsExtension(_ openGLExtension: Swift.String) -> Swift.Bool
  public func deviceSupportsRedTextures() -> Swift.Bool
  public func deviceSupportsFramebufferReads() -> Swift.Bool
  public func sizeThatFitsWithinATextureForSize(_ size: BVPSE.Size) -> BVPSE.Size
  public func textureVBO(for rotation: BVPSE.Rotation) -> OpenGLES.GLuint
}
@_semantics("sil.optimize.never") public func debugPrint(_ stringToPrint: Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line, function: Swift.StaticString = #function)
public class HardLightBlend : BVPSE.BasicOperation {
  public init()
  @objc deinit
}
extension BVPSE.ImageOrientation : Swift.Equatable {}
extension BVPSE.ImageOrientation : Swift.Hashable {}
extension BVPSE.Rotation : Swift.Equatable {}
extension BVPSE.Rotation : Swift.Hashable {}
extension BVPSE.PhysicalCameraLocation : Swift.Equatable {}
extension BVPSE.PhysicalCameraLocation : Swift.Hashable {}
extension BVPSE.FillMode : Swift.Equatable {}
extension BVPSE.FillMode : Swift.Hashable {}
extension BVPSE.HistogramType : Swift.Equatable {}
extension BVPSE.HistogramType : Swift.Hashable {}
extension BVPSE.PictureFileFormat : Swift.Equatable {}
extension BVPSE.PictureFileFormat : Swift.Hashable {}
extension BVPSE.PixelFormat : Swift.Equatable {}
extension BVPSE.PixelFormat : Swift.Hashable {}
